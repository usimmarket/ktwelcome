<!DOCTYPE html>
<html lang="ko">
<head>
<meta charset="utf-8"/>
<meta name="viewport" content="width=device-width,initial-scale=1"/>
<title>PDF 1:1 좌표 매핑 스튜디오 v3.3 (PDF+이미지, 오프셋 포함)</title>
<style>
  :root { color-scheme: dark; }
  body{margin:0;background:#0b0f14;color:#e8eef6;font:14px/1.4 system-ui,Segoe UI,Roboto,Apple SD Gothic Neo,Malgun Gothic,sans-serif}
  .row{display:grid;grid-template-columns:320px 1fr 360px;gap:16px;padding:12px}
  .card{background:#111826;border:1px solid #213043;border-radius:10px;padding:12px}
  .card h3{margin:0 0 8px;font-size:14px;color:#9ec3ff}
  input,select,button,textarea{background:#0d141e;border:1px solid #2a3a52;color:#dfe9f6;border-radius:8px;padding:8px;font:inherit}
  input[type="number"]{width:90px}
  button{cursor:pointer}
  .flex{display:flex;gap:8px;flex-wrap:wrap}
  .stack{display:flex;flex-direction:column;gap:8px}
  .list{height:260px;overflow:auto;border:1px dashed #2a3a52;border-radius:8px;padding:6px}
  .item{padding:6px;border-radius:6px;margin:4px 0;border:1px solid #2a3a52;cursor:pointer}
  .item.sel{outline:2px solid #58a6ff;background:#0f1a2a}
  canvas{background:#fff;border:1px solid #2a3a52;border-radius:8px;display:block;margin:0 auto;max-width:100%}
  .toolbar{display:flex;align-items:center;gap:8px;margin:6px 0}
  .badge{padding:2px 8px;border-radius:999px;background:#142236;color:#9ec3ff;border:1px solid #20324b;font-size:12px}
  .muted{opacity:.7}
  .grid2{display:grid;grid-template-columns:1fr 1fr;gap:8px}
  .grid3{display:grid;grid-template-columns:repeat(3,1fr);gap:8px}
  .danger{border-color:#7a1e1e;background:#1b0d0d}
</style>

<!-- PDF.js -->
<script src="https://cdnjs.cloudflare.com/ajax/libs/pdf.js/3.11.174/pdf.min.js"></script>
<script>
pdfjsLib.GlobalWorkerOptions.workerSrc =
  "https://cdnjs.cloudflare.com/ajax/libs/pdf.js/3.11.174/pdf.worker.min.js";
</script>
</head>
<body>

<div class="row">

  <!-- 좌: 소스/필드/핀 목록 -->
  <div class="card stack">
    <h3>소스 / 필드 목록</h3>

    <div class="stack">
      <div class="stack">
        <div class="flex">
          <input id="srcUrl" placeholder="PDF 또는 이미지 URL 입력"/>
          <button onclick="loadSourceFromUrl()">불러오기</button>
        </div>
        <div class="flex">
          <input id="srcFile" type="file" accept=".pdf,.png,.jpg,.jpeg" onchange="loadSourceFromFile(this)"/>
          <span class="badge">1pt = 1px · PDF 좌표 그대로</span>
        </div>
      </div>

      <div class="stack">
        <div class="flex">
          <input id="indexFile" type="file" accept=".html,.htm" />
          <button onclick="loadNamesFromIndex()">index.html 에서 name= 자동 수집</button>
        </div>
        <div id="nameList" class="list" style="height:180px"></div>
        <div class="muted" style="font-size:12px">이름을 더블클릭하면 아래 key 입력에 채워집니다.</div>
      </div>

      <div class="stack">
        <h3>텍스트 핀 목록(전체 페이지)</h3>
        <div id="pinList" class="list"></div>
        <div class="flex">
          <button onclick="exportJson()">JSON 내보내기</button>
          <input id="jsonFile" type="file" accept=".json" onchange="importJson(this)"/>
          <button class="danger" onclick="removeSelected()">선택 삭제</button>
          <button onclick="duplicateSelected()">선택 복제</button>
        </div>
      </div>
    </div>
  </div>

  <!-- 중앙: 캔버스/툴 -->
  <div class="card stack">
    <div class="toolbar">
      <button id="btnPrev" onclick="gotoPrevPage()">이전</button>
      <span id="pageLabel" class="badge">Page - / -</span>
      <button id="btnNext" onclick="gotoNextPage()">다음</button>
      <label class="flex" style="align-items:center;gap:6px;margin-left:auto">
        <input type="checkbox" id="onlyThisPage" checked/> 이 페이지 핀만 표시
      </label>
    </div>

    <canvas id="pdfCanvas"></canvas>

    <div class="card stack" style="background:#0f1624">
      <div class="flex">
        <div class="badge">모드</div>
        <select id="mode">
          <option value="text">텍스트</option>
          <option value="check">체크박스</option>
          <option value="fixed">고정라벨</option>
        </select>
        <div class="badge">page</div>
        <input id="pageInput" type="number" value="1" min="1" step="1"/>
        <div class="badge">size</div>
        <input id="sizeInput" type="number" value="10" min="1" step="1"/>
      </div>

      <div class="flex">
        <input id="keyInput" placeholder="key (필드명)"/>
        <button onclick="startClickPick()">캔버스 클릭으로 좌표 찍기</button>
        <button onclick="applyPin()">적용</button>
      </div>

      <div class="flex">
        <div class="badge">X</div><input id="xInput" type="number" value="0" step="1"/>
        <div class="badge">Y</div><input id="yInput" type="number" value="0" step="1"/>
        <span class="muted">선택 핀을 1pt 이동</span>
        <div class="flex">
          <button onclick="nudge(0,-1)">↑</button>
          <button onclick="nudge(-1,0)">←</button>
          <button onclick="nudge(1,0)">→</button>
          <button onclick="nudge(0,1)">↓</button>
        </div>
      </div>

      <div class="grid2">
        <button onclick="previewSelected()">선택 미리보기</button>
        <button onclick="clearSelection()">선택 해제</button>
      </div>
    </div>

    <!-- 일괄 오프셋 -->
    <div class="card">
      <h3>일괄 오프셋(Δx/Δy) <span class="muted">단위: cm 또는 pt</span></h3>
      <div class="grid3">
        <div>
          <div class="muted">ΔX(cm)</div>
          <input id="dxCm" type="number" step="0.1" value="-1.5"/>
        </div>
        <div>
          <div class="muted">ΔY(cm)</div>
          <input id="dyCm" type="number" step="0.1" value="-1.7"/>
        </div>
        <div></div>
        <div>
          <div class="muted">ΔX(pt)</div>
          <input id="dxPt" type="number" step="0.01" value="-42.52"/>
        </div>
        <div>
          <div class="muted">ΔY(pt)</div>
          <input id="dyPt" type="number" step="0.01" value="-48.19"/>
        </div>
        <div class="stack">
          <button onclick="applyOffsetAll()">전체 핀에 적용</button>
          <button onclick="applyOffsetThisPage()">이 페이지 핀만 적용</button>
        </div>
      </div>
      <div class="muted" style="margin-top:6px">+X→오른쪽, +Y→아래쪽 · “위로/왼쪽” 이동은 음수 사용</div>
    </div>

  </div>

  <!-- 우: 체크박스/고정 라벨 -->
  <div class="card stack">
    <h3>체크박스(vmap) <span class="muted">목록은 전체 페이지</span></h3>
    <div class="stack">
      <input id="optInput" placeholder="opt (예: join_type:new)"/>
      <div class="flex">
        <div class="badge">x</div><input id="cxInput" type="number" value="0"/>
        <div class="badge">y</div><input id="cyInput" type="number" value="0"/>
        <div class="badge">size</div><input id="csizeInput" type="number" value="11"/>
        <div class="badge">page</div><input id="cpageInput" type="number" value="1"/>
      </div>
      <div class="flex"><button onclick="addCheck()">추가</button><button onclick="listChecks()">목록</button></div>
      <div id="checkList" class="list" style="height:160px"></div>
    </div>

    <h3>고정 라벨 (fixed_flags)</h3>
    <div class="stack">
      <input id="labelInput" placeholder="label 텍스트(예: 국제전화차단/로밍차단)"/>
      <div class="flex">
        <div class="badge">x</div><input id="fxInput" type="number" value="0"/>
        <div class="badge">y</div><input id="fyInput" type="number" value="0"/>
        <div class="badge">size</div><input id="fsizeInput" type="number" value="10"/>
        <div class="badge">page</div><input id="fpageInput" type="number" value="1"/>
      </div>
      <div class="flex"><button onclick="addFixed()">추가</button><button onclick="listFixed()">목록</button></div>
      <div id="fixedList" class="list" style="height:160px"></div>
    </div>
  </div>

</div>

<script>
/* ---------------------- 상태 ---------------------- */
let pdfDoc=null, pdfPageIndex=1, pdfPageCount=0;
let isPicking=false;
const mapping = { fields:{}, vmap:{}, fixed_flags:{ intl_roaming_block:[] } };
let selectedId=null; // 'fields:key' 형태

/* ---------------------- 유틸 ---------------------- */
const cm2pt = (cm)=> cm*28.3464567;
function $(id){ return document.getElementById(id); }
function currentPage(){ return Number($("#pageInput").value||1); }
function currentSize(){ return Number($("#sizeInput").value||10); }
function selectItem(id){ selectedId=id; renderPinList(); fillEditorFromSelection(); }
function clearSelection(){ selectedId=null; renderPinList(); }

/* ---------------------- 소스 로딩 ---------------------- */
async function loadSourceFromUrl(){
  const url = $("#srcUrl").value.trim();
  if(!url) return;
  if(url.toLowerCase().endsWith(".pdf")) await loadPdfToCanvas(url);
  else await loadImageToCanvas(url);
}
async function loadSourceFromFile(input){
  const f = input.files?.[0]; if(!f) return;
  const url = URL.createObjectURL(f);
  if(f.name.toLowerCase().endsWith(".pdf")) await loadPdfToCanvas(url);
  else await loadImageToCanvas(url);
}

/* ---- PDF ---- */
async function loadPdfToCanvas(url){
  pdfDoc = await pdfjsLib.getDocument({url}).promise;
  pdfPageCount = pdfDoc.numPages; pdfPageIndex=1;
  await renderPdfPage(pdfPageIndex); updatePageUi();
}
async function renderPdfPage(n){
  const page = await pdfDoc.getPage(n);
  const viewport = page.getViewport({scale:1}); // 1pt=1px
  const canvas = $("#pdfCanvas"), ctx = canvas.getContext("2d",{willReadFrequently:true});
  canvas.width = Math.round(viewport.width); canvas.height = Math.round(viewport.height);
  await page.render({canvasContext:ctx, viewport}).promise;
  redrawPinsOnCanvas();
}
function updatePageUi(){
  $("#pageLabel").textContent = `Page ${pdfPageIndex} / ${pdfPageCount}`;
  $("#btnPrev").disabled = pdfPageIndex<=1;
  $("#btnNext").disabled = pdfPageIndex>=pdfPageCount;
  $("#pageInput").value = pdfPageIndex;
  renderPinList(); redrawPinsOnCanvas();
}
async function gotoPrevPage(){ if(!pdfDoc||pdfPageIndex<=1) return; pdfPageIndex--; await renderPdfPage(pdfPageIndex); updatePageUi(); }
async function gotoNextPage(){ if(!pdfDoc||pdfPageIndex>=pdfPageCount) return; pdfPageIndex++; await renderPdfPage(pdfPageIndex); updatePageUi(); }

/* ---- 이미지 ---- */
async function loadImageToCanvas(url){
  const img=new Image(); img.crossOrigin="anonymous";
  await new Promise((res,rej)=>{ img.onload=res; img.onerror=rej; img.src=url; });
  const canvas=$("#pdfCanvas"), ctx=canvas.getContext("2d",{willReadFrequently:true});
  canvas.width=img.naturalWidth; canvas.height=img.naturalHeight;
  ctx.drawImage(img,0,0);
  pdfDoc=null; pdfPageCount=1; pdfPageIndex=1; updatePageUi();
}

/* ---------------------- 이름 목록 ---------------------- */
async function loadNamesFromIndex(){
  const f = $("#indexFile").files?.[0]; if(!f) return;
  const html = await f.text();
  const names = Array.from(html.matchAll(/\bname\s*=\s*["']([^"']+)["']/gi)).map(m=>m[1]);
  const unique=[...new Set(names)].sort((a,b)=>a.localeCompare(b));
  const box=$("#nameList"); box.innerHTML="";
  unique.forEach(n=>{
    const div=document.createElement("div");
    div.className="item"; div.textContent=n;
    div.title="더블클릭하면 key 입력에 채워집니다.";
    div.ondblclick=()=>{$("#keyInput").value=n;};
    box.appendChild(div);
  });
}

/* ---------------------- 좌표 추가/편집 ---------------------- */
$("#pdfCanvas").addEventListener("click",(e)=>{
  if(!isPicking) return;
  const rect=e.target.getBoundingClientRect();
  const x = Math.round(e.clientX-rect.left);
  const y = Math.round(e.clientY-rect.top);
  $("#xInput").value=x; $("#yInput").value=y;
  isPicking=false;
});
function startClickPick(){ isPicking=true; }

function applyPin(){
  const mode=$("#mode").value, key=$("#keyInput").value.trim();
  const x=Number($("#xInput").value||0), y=Number($("#yInput").value||0);
  const size=currentSize(), p=currentPage();
  if(mode==="text"){
    if(!key) return alert("key를 입력하세요");
    mapping.fields[key]={x,y,size,page:p};
    selectedId="fields:"+key;
  }else if(mode==="check"){
    const opt=$("#optInput").value.trim(); if(!opt) return alert("opt 입력");
    mapping.vmap[opt]={x,y,size,page:p};
    selectedId=null;
  }else{
    const label=$("#labelInput").value||"";
    mapping.fixed_flags.intl_roaming_block.push({label,x,y,size,page:p});
    selectedId=null;
  }
  renderPinList(); redrawPinsOnCanvas();
}
function removeSelected(){
  if(!selectedId) return;
  const [grp,key]=selectedId.split(":");
  if(grp==="fields"){ delete mapping.fields[key]; }
  selectedId=null; renderPinList(); redrawPinsOnCanvas();
}
function duplicateSelected(){
  if(!selectedId) return;
  const [grp,key]=selectedId.split(":");
  if(grp!=="fields") return;
  const def={...mapping.fields[key]};
  let k=key+"_copy"; let i=1; while(mapping.fields[k]) k=key+"_copy"+(++i);
  mapping.fields[k]=def; selectedId="fields:"+k; renderPinList(); redrawPinsOnCanvas();
}
function nudge(dx,dy){
  if(!selectedId) return;
  const [grp,key]=selectedId.split(":");
  if(grp!=="fields") return;
  const def=mapping.fields[key];
  def.x=(Number(def.x)||0)+dx; def.y=(Number(def.y)||0)+dy;
  $("#xInput").value=def.x; $("#yInput").value=def.y;
  redrawPinsOnCanvas(); renderPinList();
}
function previewSelected(){
  if(!selectedId) return;
  redrawPinsOnCanvas(true);
}
function fillEditorFromSelection(){
  if(!selectedId) return;
  const [grp,key]=selectedId.split(":"); if(grp!=="fields") return;
  const d=mapping.fields[key];
  $("#mode").value="text";
  $("#keyInput").value=key; $("#xInput").value=d.x; $("#yInput").value=d.y;
  $("#sizeInput").value=d.size; $("#pageInput").value=d.page;
}

/* ---------------------- 리스트 렌더 ---------------------- */
function renderPinList(){
  const only = $("#onlyThisPage").checked, p=pdfPageIndex;
  const box=$("#pinList"); box.innerHTML="";
  const entries=Object.entries(mapping.fields);
  for(const [k,d] of entries){
    if(only && Number(d.page)!==p) continue;
    const div=document.createElement("div");
    div.className="item"+(selectedId==="fields:"+k?" sel":"");
    div.onclick=()=>selectItem("fields:"+k);
    div.textContent = `${k} @(${d.x},${d.y}) p${d.page}`;
    box.appendChild(div);
  }
  listChecks(); listFixed();
}
function listChecks(){
  const b=$("#checkList"); b.innerHTML="";
  for(const [k,d] of Object.entries(mapping.vmap)){
    const div=document.createElement("div");
    div.className="item"; div.textContent=`${k} @(${d.x},${d.y}) p${d.page}`;
    b.appendChild(div);
  }
}
function listFixed(){
  const b=$("#fixedList"); b.innerHTML="";
  for(const d of mapping.fixed_flags.intl_roaming_block){
    const div=document.createElement("div");
    div.className="item"; div.textContent=`${d.label||"(label)"} @(${d.x},${d.y}) p${d.page}`;
    b.appendChild(div);
  }
}

/* ---------------------- 체크/고정 라벨 추가 ---------------------- */
function addCheck(){
  const opt=$("#optInput").value.trim(); if(!opt) return alert("opt 입력");
  mapping.vmap[opt]={x:Number($("#cxInput").value||0),y:Number($("#cyInput").value||0),
                     size:Number($("#csizeInput").value||11),page:Number($("#cpageInput").value||1)};
  listChecks(); redrawPinsOnCanvas();
}
function addFixed(){
  const label=$("#labelInput").value||"";
  mapping.fixed_flags.intl_roaming_block.push({
    label,
    x:Number($("#fxInput").value||0),
    y:Number($("#fyInput").value||0),
    size:Number($("#fsizeInput").value||10),
    page:Number($("#fpageInput").value||1),
  });
  listFixed(); redrawPinsOnCanvas();
}

/* ---------------------- 일괄 오프셋 ---------------------- */
function readOffsetPt(){
  let dx = Number($("#dxPt").value||0), dy=Number($("#dyPt").value||0);
  // cm 값이 입력돼 있으면 cm 우선
  const dxCm = $("#dxCm").value, dyCm=$("#dyCm").value;
  if(dxCm!=="" || dyCm!==""){
    dx = Number(dxCm||0)*28.3464567;
    dy = Number(dyCm||0)*28.3464567;
  }
  return {dx,dy};
}
function applyOffsetAll(){
  const {dx,dy}=readOffsetPt();
  for(const d of Object.values(mapping.fields)){ d.x+=dx; d.y+=dy; }
  for(const d of Object.values(mapping.vmap)){ d.x+=dx; d.y+=dy; }
  for(const d of mapping.fixed_flags.intl_roaming_block){ d.x+=dx; d.y+=dy; }
  renderPinList(); redrawPinsOnCanvas();
}
function applyOffsetThisPage(){
  const p=pdfPageIndex; const {dx,dy}=readOffsetPt();
  for(const d of Object.values(mapping.fields)){ if(Number(d.page)===p){ d.x+=dx; d.y+=dy; } }
  for(const d of Object.values(mapping.vmap)){ if(Number(d.page)===p){ d.x+=dx; d.y+=dy; } }
  for(const d of mapping.fixed_flags.intl_roaming_block){ if(Number(d.page)===p){ d.x+=dx; d.y+=dy; } }
  renderPinList(); redrawPinsOnCanvas();
}

/* ---------------------- JSON I/O ---------------------- */
function exportJson(){
  const blob=new Blob([JSON.stringify(mapping,null,2)],{type:"application/json"});
  const a=document.createElement("a"); a.href=URL.createObjectURL(blob);
  a.download="KT_mapping_legacy_names.json"; a.click();
}
async function importJson(input){
  const f = input.files?.[0]; if(!f) return;
  const text=await f.text();
  const obj=JSON.parse(text);
  // 방어: 부분만 있어도 병합
  mapping.fields = obj.fields || {};
  mapping.vmap   = obj.vmap   || {};
  mapping.fixed_flags = obj.fixed_flags || {intl_roaming_block:[]};
  renderPinList(); redrawPinsOnCanvas();
}

/* ---------------------- 캔버스 오버레이 ---------------------- */
function redrawPinsOnCanvas(highlight=false){
  const c=$("#pdfCanvas"), ctx=c.getContext("2d");
  if(!ctx) return;
  // 반투명 오버레이 박스들만 그려서 위치 확인
  const p=pdfPageIndex, only=$("#onlyThisPage").checked;

  function drawBox(x,y,w,h,color){ ctx.save(); ctx.strokeStyle=color; ctx.lineWidth=1; ctx.strokeRect(x,y,w,h); ctx.restore(); }

  // 텍스트
  for(const [k,d] of Object.entries(mapping.fields)){
    if(only && Number(d.page)!==p) continue;
    drawBox(d.x-3,d.y-3,6,6, (selectedId==="fields:"+k && highlight)?"#00e0ff":"#ff5959");
  }
  // 체크
  for(const d of Object.values(mapping.vmap)){
    if(only && Number(d.page)!==p) continue;
    drawBox(d.x-4,d.y-4,8,8,"#a4ff7a");
  }
  // 고정 라벨
  for(const d of mapping.fixed_flags.intl_roaming_block){
    if(only && Number(d.page)!==p) continue;
    drawBox(d.x-4,d.y-4,8,8,"#7ab3ff");
  }
}
<script>
const $ = (s, p=document) => p.querySelector(s);

// PDF: 로컬 파일 로더
const pdfFileInput = document.getElementById('pdfFileInput');      // id는 현재 파일 input의 id로 맞춰주세요
const pdfUrlInput  = document.getElementById('pdfUrlInput');       // URL 입력칸
const pdfLoadBtn   = document.getElementById('pdfLoadBtn');        // "불러오기" 버튼

// index.html 로더
const idxFileInput = document.getElementById('indexFileInput');    // index.html 파일 input
const idxLoadBtn   = document.getElementById('indexLoadBtn');      // "로드" 버튼

function toast(msg, ok=false){
  console[ok?'log':'warn'](msg);
  // 필요하면 실제 토스트 UI로 교체
  alert(msg);
}

// PDF 로컬 파일 -> 이미지/캔버스 로드
async function loadLocalPdf(file){
  try {
    if(!file) return;
    const buf = await file.arrayBuffer();
    // 내부 기존 함수로 넘기세요 (예: renderPdfFromArrayBuffer)
    await renderPdfFromArrayBuffer(buf); 
    toast('PDF 로컬 파일 로드 완료', true);
  } catch(e){ toast('PDF 로컬 로드 실패: '+e.message); }
}

// PDF URL -> fetch -> blob -> arrayBuffer
async function loadUrlPdf(url){
  try {
    if(!url) return toast('URL을 입력하세요');
    const res = await fetch(url, { mode:'cors' });
    if(!res.ok) throw new Error('HTTP '+res.status);
    const buf = await res.arrayBuffer();
    await renderPdfFromArrayBuffer(buf);
    toast('PDF URL 로드 완료', true);
  } catch(e){
    toast('PDF URL 로드 실패 (CORS일 수 있음): '+e.message);
  }
}

// index.html -> FileReader -> 텍스트 파싱
async function loadLocalIndex(file){
  try {
    if(!file) return;
    const text = await file.text();
    // 내부 기존 파서로 넘기세요 (예: parseFieldNamesFromIndex)
    const names = parseFieldNamesFromIndex(text);
    fillFieldList(names);
    toast('index.html 로드 완료', true);
  } catch(e){ toast('index.html 로드 실패: '+e.message); }
}

// 이벤트 바인딩(중복 바인딩 방지)
if (pdfFileInput && !pdfFileInput._bound){
  pdfFileInput.addEventListener('change', e => loadLocalPdf(e.target.files?.[0]));
  pdfFileInput._bound = true;
}
if (pdfLoadBtn && !pdfLoadBtn._bound){
  pdfLoadBtn.addEventListener('click', () => loadUrlPdf(pdfUrlInput?.value?.trim()));
  pdfLoadBtn._bound = true;
}
if (idxLoadBtn && !idxLoadBtn._bound){
  idxLoadBtn.addEventListener('click', () => loadLocalIndex(idxFileInput?.files?.[0]));
  idxLoadBtn._bound = true;
}
</script>

/* ---------------------- 초기 ---------------------- */
renderPinList();
</script>
</body>
</html>
