<!DOCTYPE html>
<html lang="ko">
<head>
<meta charset="utf-8"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>KT 폼 좌표 매핑 스튜디오 PRO (1pt=1px · 멀티페이지 자동 내보내기)</title>
<style>
  :root { --bg:#0f172a; --ink:#e5e7eb; --panel:#111827; --line:#334155; }
  * { box-sizing: border-box; }
  body { margin:0; font-family:-apple-system, BlinkMacSystemFont,"Segoe UI",Roboto,"Noto Sans KR",Arial,sans-serif; color:var(--ink); background:var(--bg); }
  header { display:flex; gap:12px; align-items:center; padding:10px; background:#0b1220; position:sticky; top:0; z-index:10; }
  header input, header select, header button { font-size:14px; padding:6px 8px; border-radius:8px; border:1px solid var(--line); background:var(--panel); color:var(--ink); }
  header button.primary { background:#2563eb; border-color:#2563eb; }
  #wrap { display:grid; grid-template-columns: 1fr 380px; height: calc(100vh - 58px); }
  #viewer { overflow:auto; background:#0b1220; display:flex; justify-content:center; }
  #sidebar { border-left:1px solid var(--line); padding:12px; overflow:auto; background:#0b1220; }
  #pdfCanvas { background:#fff; margin:16px; box-shadow:0 10px 30px rgba(0,0,0,.35); }
  .row { display:flex; gap:8px; flex-wrap:wrap; align-items:center; }
  .spacer { flex:1 }
  .item { display:flex; gap:6px; align-items:center; padding:6px 0; border-bottom:1px dashed #24304a; }
  .item input[type="number"] { width:80px; }
  .badge { font-size:12px; padding:2px 6px; background:#eef2ff; color:#3730a3; border-radius:999px; }
  .overlay { position:absolute; inset:0 }
  .cross { position:absolute; width:12px; height:12px; pointer-events:none; }
  .cross:before, .cross:after { content:""; position:absolute; background:red; }
  .cross:before { left:-6px; right:-6px; top:0; bottom:0; height:1px; }
  .cross:after  { top:-6px; bottom:-6px; left:0; right:0; width:1px; }
  .label { position:absolute; background:rgba(255,255,255,.92); border:1px solid #fca5a5; color:#111; font-size:11px; padding:2px 4px; border-radius:4px; transform:translate(10px,6px); white-space:nowrap; }
  h3 { margin:8px 0 6px; }
  small.hint { color:#a3a3a3 }
</style>
</head>
<body>
<header>
  <div class="row">
    <label>PDF 경로 <input id="pdfUrl" value="/template.pdf" style="width:280px"/></label>
    <label>페이지 <input id="page" type="number" value="1" min="1" style="width:64px"/></label>
    <label>줌 <input id="zoom" type="number" value="120" min="10" max="400" style="width:72px"/>%</label>
    <button id="load" class="primary">불러오기</button>
    <span class="spacer"></span>
    <button id="exportBtn">매핑 JSON 내보내기</button>
    <input id="importFile" type="file" accept="application/json" style="display:none"/>
    <button id="importBtn">가져오기</button>
  </div>
</header>

<div id="wrap">
  <div id="viewer">
    <div style="position:relative">
      <canvas id="pdfCanvas"></canvas>
      <div class="overlay" id="overlay"></div>
    </div>
  </div>
  <aside id="sidebar">
    <h3>필드 배치 <span class="badge" id="countBadge">0</span></h3>

    <div class="row" style="margin-bottom:8px;">
      <label>필드
        <select id="fieldSelect">
          <optgroup label="일반 텍스트">
            <option>apply_date</option>
            <option>subscriber_name</option><option>birth</option><option>gender</option>
            <option>address</option><option>subscriber_phone</option><option>wish4</option>
            <option>port_number</option><option>prevcarrier</option><option>sim_serial</option>
            <option>usim_fee</option><option>pref_langs</option><option>pay_method</option>
            <option>holder_bank</option><option>pay_birth_bank</option><option>bank_name</option>
            <option>bank_account</option><option>holder_card</option><option>card_company</option>
            <option>card_number</option><option>card_exp_year</option><option>card_exp_month</option>
            <option>intl_block</option><option>roaming_block</option>
          </optgroup>
          <optgroup label="체크박스(옵션형)">
            <option>join_type</option><option>gender_cb</option><option>prevcarrier_cb</option>
            <option>prefsms</option><option>method</option>
          </optgroup>
        </select>
      </label>
      <label>옵션(체크박스) <input id="optionInput" placeholder="예: new / port / M / F / SK / LG / MVNO / EN ..." style="width:180px"/></label>
      <label>크기 <input id="sizeInput" type="number" value="10" min="6" max="24" style="width:64px"/></label>
      <button id="addField">추가</button>
    </div>

    <small class="hint">※ 같은 텍스트 필드를 여러 페이지/위치에 찍으면, 내보내기 시 자동으로 <b>_p{페이지}</b> 접미사를 붙여서 저장하고 <code>"source":[원래키]</code>로 연결합니다.</small>

    <div id="list" style="margin-top:10px;"></div>
  </aside>
</div>

<script src="https://cdnjs.cloudflare.com/ajax/libs/pdf.js/3.11.174/pdf.min.js"></script>
<script>
const $ = sel => document.querySelector(sel);
const overlay = $("#overlay");
const canvas = $("#pdfCanvas");
const ctx = canvas.getContext("2d");
let pdfDoc = null, scale = 1.2, currentPage = 1;
let items = []; // {key, option?, x, y, size, page}

/* 1pt == 1px when scale=1. We keep exact mapping with scale. */
function toPx(v){ return v * scale; }
function toPt(v){ return v / scale; }

async function render(){
  if (!pdfDoc) return;
  const page = await pdfDoc.getPage(currentPage);
  const viewport = page.getViewport({ scale });
  canvas.width = viewport.width;
  canvas.height = viewport.height;
  await page.render({ canvasContext: ctx, viewport }).promise;
  drawOverlay();
}

function drawOverlay(){
  overlay.innerHTML = "";
  items.filter(it => it.page === currentPage).forEach(it => {
    const xPx = toPx(it.x);
    const yPx = canvas.height - toPx(it.y);
    const cross = document.createElement("div");
    cross.className = "cross";
    cross.style.left = xPx + "px";
    cross.style.top  = yPx + "px";
    const lab = document.createElement("div");
    lab.className = "label";
    lab.textContent = (it.option ? `${it.key}:${it.option}` : it.key) + ` (x:${it.x}, y:${it.y}, s:${it.size}, p:${it.page})`;
    cross.appendChild(lab);
    overlay.appendChild(cross);
  });
}

async function loadPdf(){
  const url = $("#pdfUrl").value.trim();
  const zoom = parseInt($("#zoom").value, 10) || 120;
  scale = zoom / 100;
  const loadingTask = window['pdfjsLib'].getDocument(url);
  pdfDoc = await loadingTask.promise;
  currentPage = Math.min(Math.max(parseInt($("#page").value,10)||1,1), pdfDoc.numPages);
  await render();
}

overlay.addEventListener("click", (e) => {
  const r = canvas.getBoundingClientRect();
  const xPx = e.clientX - r.left;
  const yPx = e.clientY - r.top;
  const xPt = Math.round(toPt(xPx));
  const yPt = Math.round(toPt(canvas.height - yPx));

  const key = $("#fieldSelect").value;
  const option = ($("#optionInput").value || "").trim();
  const size = parseInt($("#sizeInput").value,10) || 10;

  const optionFields = new Set(["join_type","gender_cb","prevcarrier_cb","prefsms","method"]);
  if (optionFields.has(key) && !option) { alert("체크박스(옵션형)는 옵션 값을 입력하세요."); return; }

  const item = { key, option: option || null, x: xPt, y: yPt, size, page: currentPage };
  items.push(item);
  appendItemRow(item);
  drawOverlay();
});

function appendItemRow(item){
  const row = document.createElement("div");
  row.className = "item";
  row.innerHTML = `
    <span class="badge">${item.key}${item.option ? " : " + item.option : ""}</span>
    <label>x:<input type="number" value="${item.x}" style="width:70px"/></label>
    <label>y:<input type="number" value="${item.y}" style="width:70px"/></label>
    <label>size:<input type="number" value="${item.size}" style="width:60px"/></label>
    <label>p:<input type="number" value="${item.page}" style="width:52px"/></label>
    <button>삭제</button>
  `;
  const [xI,yI,sI,pI] = row.querySelectorAll("input");
  const delBtn = row.querySelector("button");
  xI.oninput = () => { item.x = parseInt(xI.value||"0",10); drawOverlay(); };
  yI.oninput = () => { item.y = parseInt(yI.value||"0",10); drawOverlay(); };
  sI.oninput = () => { item.size = parseInt(sI.value||"10",10); drawOverlay(); };
  pI.oninput = () => { item.page = parseInt(pI.value||"1",10); drawOverlay(); };
  delBtn.onclick = () => { items = items.filter(it => it !== item); row.remove(); drawOverlay(); updateCount(); };
  $("#list").appendChild(row);
  updateCount();
}

$("#addField").onclick = () => {
  const key = $("#fieldSelect").value;
  const option = ($("#optionInput").value || "").trim();
  const size = parseInt($("#sizeInput").value,10)||10;
  const item = { key, option: option || null, x: 100, y: 100, size, page: currentPage };
  items.push(item);
  appendItemRow(item);
  drawOverlay();
};

function updateCount(){ $("#countBadge").textContent = items.length; }

/* ---------- 내보내기: 중복 키 자동 접미사(_p{page}) ---------- */
$("#exportBtn").onclick = () => {
  const fields = {};
  const byKey = {};
  for (const it of items) {
    if (!byKey[it.key]) byKey[it.key] = [];
    byKey[it.key].push(it);
  }
  for (const [key, arr] of Object.entries(byKey)) {
    const optArr = arr.filter(x => x.option);
    if (optArr.length > 0) {
      // 체크박스(옵션형)
      const options = {};
      for (const o of optArr) options[o.option] = { x:o.x, y:o.y, size:o.size, page:o.page };
      fields[key] = { page: optArr[0].page || 1, options };
      continue;
    }
    // 일반 텍스트
    if (arr.length === 1) {
      const a = arr[0];
      fields[key] = { x:a.x, y:a.y, size:a.size, page:a.page, source:[key] };
      if (key === "apply_date") fields[key].format = "date:yyyy.MM.dd";
      if (key === "intl_block") fields[key].const = "적용";
      if (key === "roaming_block") fields[key].const = "적용";
    } else {
      // 같은 키가 여러 위치/페이지 → 자동으로 _p{page} 접미사 부여
      for (const a of arr) {
        const outKey = `${key}_p${a.page}`;
        fields[outKey] = { x:a.x, y:a.y, size:a.size, page:a.page, source:[key] };
        if (key === "apply_date") fields[outKey].format = "date:yyyy.MM.dd";
        if (key === "intl_block") fields[outKey].const = "적용";
        if (key === "roaming_block") fields[outKey].const = "적용";
      }
    }
  }
  const blob = new Blob([JSON.stringify({fields}, null, 2)], {type:"application/json"});
  const a = document.createElement("a");
  a.href = URL.createObjectURL(blob);
  a.download = "KT_mapping_legacy_names.json";
  a.click();
};

/* ---------- 가져오기: *_p{n} + source → base key로 복원 ---------- */
$("#importBtn").onclick = () => $("#importFile").click();
$("#importFile").onchange = async (e) => {
  const f = e.target.files[0];
  if (!f) return;
  try {
    const obj = JSON.parse(await f.text());
    items = []; $("#list").innerHTML = "";
    if (obj && obj.fields) {
      for (const [key, cfg] of Object.entries(obj.fields)) {
        if (cfg.options) {
          for (const [opt, pos] of Object.entries(cfg.options)) {
            const it = { key, option: opt, x: pos.x||0, y: pos.y||0, size: pos.size||10, page: pos.page||cfg.page||1 };
            items.push(it); appendItemRow(it);
          }
        } else {
          // base 복원: key가 *_p{n} 이고 source가 있으면 source[0]으로 표시
          const m = key.match(/^(.*)_p(\d+)$/);
          let showKey = key;
          let page = cfg.page || 1;
          if (m && cfg.source && cfg.source.length) {
            showKey = cfg.source[0];
            page = parseInt(m[2],10) || page;
          }
          const it = { key: showKey, option: null, x: cfg.x||0, y: cfg.y||0, size: cfg.size||10, page };
          items.push(it); appendItemRow(it);
        }
      }
    }
    drawOverlay();
  } catch (err) { alert("JSON 파싱 실패: " + err.message); }
};

$("#load").onclick = loadPdf;
$("#page").onchange = render;
$("#zoom").onchange = loadPdf;
window.addEventListener("load", loadPdf);
</script>
</body>
</html>
